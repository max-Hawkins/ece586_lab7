#include <iostream>
#include <fstream>
#include <string.h>
#include <math.h>

using namespace std;

/* 
    Memory Operation structure that the simulator will execute.
    Parsed in from the input file.
Members:
    Character op_type: Memory operation type. 'R' = Read and 'W' = Write
    Integer mem_address: The numeric memory address to either read or write
*/
struct memOp{
    char op_type;
    int  mem_address;
    int  mem_block;
    int  cache_set;
    int  cache_block_start;
    string result;
};

/*
    Memory Simulator Class

Used to store all necessary information for the simulation
of a memory hierarchy and memory operations.



*/
class MemorySim{
public:
    int size_main_mem;
    int size_cache;
    int size_line;
    int assoc_deg;
    char replace_policy;
    string input_filename;

    MemorySim(){}

    void display(){
        cout << "\n--- Memory Sim ---" ;
        cout << "\nMain Mem size: " << size_main_mem;
        cout << "\nCache size   : " << size_cache;
        cout << "\nLine size    : " << size_line;
        cout << "\nDegree of ass: " << assoc_deg;
        cout << "\nReplace Pol  : " << replace_policy;
        cout << "\nInput File   : " << input_filename;

        cout << endl;
    }

    void calc_mem_addr_layout(){
        // Calculate number of address, convert to integer, and print to screen
        int num_addr_lines = (int)log2(size_main_mem);
        cout << "Total address lines required = " << num_addr_lines << endl;
        // Calculate number of offset bits, convert to integer, and print to screen
        int num_offset_bits = (int)log2(size_line);
        cout << "Number of bits for offset = " << num_offset_bits << endl;
        // Calculate number of index bits, convert to integer, and print to screen
        int num_index_bits = (int)log2(size_cache / size_line / assoc_deg);
        cout << "Number of bits for index = " << num_index_bits << endl;
        // Calculate number of tag bits and print to screen
        int num_tag_bits = num_addr_lines - num_offset_bits - num_index_bits;
        cout << "Number of bits for tag = " << num_tag_bits << endl;
        // Calculate cache size required and print to screen
        // num_cache_blks * (1+1(dirty and valid bits) + num_tag_bits + 8 * block_size) / 8
        int size_total_cache = (int)(size_cache / size_line * (1 + 1 + num_tag_bits) / 8 + size_cache);
        cout << "Total cache size required = " << size_total_cache << " bytes" << endl;
    }
};

void display_ops(memOp ops[], int num_ops, int assoc_deg){
    // String variable to store each memory addresses potential cache memory blocks
    string cache_blocks = "";
    cout << "Displaying ops" << endl;
    cout << "\n\nmain memory address\tmm blk #\tcm set #\tcm blk #\thit/miss" << endl;
    cout << "-----------------------------------------------------------------------------------" << endl;
    for(int i=0; i < num_ops; i++){
        cache_blocks = to_string(ops[i].cache_block_start);
        for(int block=1; block < assoc_deg; block++){
            cache_blocks.append(" or " + to_string(ops[i].cache_set + block));
        }
        printf("%8d %20d %15d %17s %14s\n", ops[i].mem_address, ops[i].mem_block, ops[i].cache_set, cache_blocks.c_str(), ops[i].result.c_str());
    }
}

int main(int argc, char *argv[]) {

    char cont_input;

    while(1){

        MemorySim mem_sim = MemorySim();

        cout << "Enter the size of main memory in bytes: ";
        cin >> mem_sim.size_main_mem;
        cout << "Enter the size of the cache in bytes: ";
        cin >> mem_sim.size_cache;
        cout << "Enter the block/line size: ";
        cin >> mem_sim.size_line;
        cout << "Enter the degree of set-associativity (input n for an n-way set-associative mapping): ";
        cin >> mem_sim.assoc_deg;
        cout << "Enter the replacement policy (L = LRU, F = FIFO): ";
        cin >> mem_sim.replace_policy;
        cout << "Enter the name of the input file containing the list of memory references generated by the CPU:";
        cin >> mem_sim.input_filename;

        mem_sim.display();

        //----------------------------
        // Parse memory operation file
        //----------------------------
        std::ifstream input_stream;
        int num_mem_ops;
        input_stream.open(mem_sim.input_filename);
        input_stream >> num_mem_ops;
        memOp operations[num_mem_ops];
        // Ignore empty line in input file
        string s;
        getline(input_stream,  s);
        char op_char;
        int mem_loc;
        // Parse input memory operations into operations array
        for(int i=0; i<num_mem_ops; i++){
            input_stream >> operations[i].op_type;
            input_stream >> operations[i].mem_address;


            operations[i].mem_block = floor(operations[i].mem_address / mem_sim.size_line);
            operations[i].cache_set = operations[i].mem_block % (mem_sim.size_cache / mem_sim.size_line / mem_sim.assoc_deg);
            operations[i].cache_block_start = operations[i].cache_set * mem_sim.assoc_deg;
            operations[i].result = "TBD";
        }

        mem_sim.calc_mem_addr_layout();

        // TODO: Execute operations

        // Print table of memory operations and associated information
        display_ops(operations, num_mem_ops, mem_sim.assoc_deg);

        // Check if user wants to run another memory simulator
        cout << "Continue? (y = yes, n = no): ";
        cin  >> cont_input;
        // Only continue if input is 'y'since don't need to error check
        // If the input isn't y, default to ending program
        if(cont_input != 'y')
            return 0; // End program
    }
    //return 0;
}